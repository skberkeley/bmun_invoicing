package invoice_automation.module;

import com.intuit.ipp.core.Context;
import com.intuit.ipp.core.ServiceType;
import com.intuit.ipp.data.Customer;
import com.intuit.ipp.data.EmailStatusEnum;
import com.intuit.ipp.data.Invoice;
import com.intuit.ipp.data.Item;
import com.intuit.ipp.data.MemoRef;
import com.intuit.ipp.data.ReferenceType;
import com.intuit.ipp.exception.FMSException;
import com.intuit.ipp.query.GenerateQuery;
import com.intuit.ipp.security.OAuth2Authorizer;
import com.intuit.ipp.services.DataService;
import com.intuit.ipp.services.QueryResult;
import com.intuit.ipp.util.Config;
import invoice_automation.QuickBooksException;
import invoice_automation.utils.QuickBooksUtil;
import invoice_automation.model.Conference;
import invoice_automation.model.InvoiceType;
import invoice_automation.model.ItemType;
import invoice_automation.model.PaymentMethod;
import invoice_automation.model.Registration;
import invoice_automation.model.RegistrationRound;
import invoice_automation.model.School;
import lombok.Builder;
import lombok.NonNull;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

import static invoice_automation.Consts.SANDBOX_BASE_URL;

/**
 * Abstraction barrier for calling QuickBooks APIs
 *
 * @author skberkeley
 */
public class QuickBooksModule {
    /**
     * The DataService object used to make QuickBooks API calls
     */
    private final DataService dataService;

    /**
     * Creates a new QuickBooksModule object, instantiating a new DataService object in the process.
     * accessToken must be a valid value generated by some OAuth2 process.
     * realmId must be a valid value for some QuickBooks app.
     * @param accessToken The OAuth2 accessToken used to authenticate while instantiating the new DataService object
     * @param realmId The realmId for the QuickBooks app being used
     * @param useSandbox Whether API calls should be made to the sandbox endpoint (for testing)
     */
    @Builder
    public QuickBooksModule(@NonNull String accessToken, @NonNull String realmId, boolean useSandbox) {
        if (useSandbox) {
            Config.setProperty(Config.BASE_URL_QBO, SANDBOX_BASE_URL);
        }

        // Create OAuth2 object
        OAuth2Authorizer oAuth2Authorizer = new OAuth2Authorizer(accessToken);

        // Create QuickBooks context
        Context context;
        try {
            context = new Context(oAuth2Authorizer, ServiceType.QBO, realmId);
        } catch (FMSException e) {
            throw new QuickBooksException("Exception creating context for QuickBooksModule", e);
        }

        // Create QuickBooks DataService object
        this.dataService = new DataService(context);
    }

    // Customer methods


    /**
     * Gets the corresponding QuickBooks Customer, by matching the school name and the Customer's display name. If no
     * matching Customer exists, returns null.
     * @param school - The school to match against using the school's name
     * @return - The matching Customer object
     */
    private Customer queryCustomerFromSchool(@NonNull School school) {
        String query = QueryModule.getQueryForCustomerFromSchool(school.getSchoolName());
        QueryResult queryResult;
        try {
            queryResult = this.dataService.executeQuery(query);
        } catch (FMSException e) {
            throw new QuickBooksException("Exception getting customer", e);
        }
        if (queryResult == null || queryResult.getEntities().isEmpty()) {
            return null;
        }
        return (Customer) queryResult.getEntities().get(0);
    }

    /**
     * Get a list of all existing customers through the QuickBooks API
     * @return A list of all existing customers
     */
    public List<Customer> getAllCustomers() {
        String query = "SELECT * FROM customer";
        QueryResult queryResult;
        try {
            queryResult = this.dataService.executeQuery(query);
        } catch (FMSException e) {
            throw new QuickBooksException("Exception getting all customers", e);
        }
        return (List<Customer>) queryResult.getEntities();
    }

    /**
     * Updates the corresponding QuickBooks Customer and returns a copy of that object. If no corresponding Customer
     * exists, then a new one is created.
     * @return A copy of the Customer updated or created
     */
    public Customer updateCustomerFromSchool(@NonNull School school) {
        Customer queriedCustomer = this.queryCustomerFromSchool(school);
        Customer newCustomer = QuickBooksUtil.getCustomerFromSchool(school);
        // Add newCustomer or update the existing customer
        if (queriedCustomer == null) {
            try {
                dataService.add(newCustomer);
            } catch (FMSException e) {
                throw new QuickBooksException("Exception adding customer", e);
            }
        } else {
            try {
                newCustomer.setId(queriedCustomer.getId());
                newCustomer.setSyncToken(queriedCustomer.getSyncToken());
                newCustomer.setSparse(true);
                dataService.update(newCustomer);
            } catch (FMSException e) {
                throw new QuickBooksException("Exception updating customer", e);
            }
        }
        return newCustomer;
    }

    // Invoice methods

    /**
     * Get all the invoices corresponding to the passed registration through the QuickBooks API. An invoice matches if:
     * - The Invoice's Customer field matches the Registration's School
     * - The Invoice's line items correspond to the Registration's Conference
     * If matching invoices exist, we expect two, one for the school fee and another for delegate fees.
     * If no matching invoices exist, returns an empty map.
     * @param registration The Registration to match invoices against
     * @return A map from InvoiceType to the corresponding Invoice. May be empty if no matching invoices exist
     */
    public Map<InvoiceType, Invoice> queryInvoicesFromRegistration(@NonNull Registration registration) {
        // Get Customer to match against
        Customer customer = this.queryCustomerFromSchool(registration.getSchool());
        if (customer == null) {
            // If no matching customer exists, then no matching invoices exist
            return Map.of();
        }

        // Get all invoices
        List<Invoice> allInvoices = this.getAllInvoices();

        // If no invoices for the customer, return an empty map
        if (allInvoices.stream().filter(i -> QuickBooksUtil.checkInvoiceMatchesCustomer(i, customer)).findAny().isEmpty()) {
            return Map.of();
        }

        // Filter invoices for matching customer
        Stream<Invoice> matchingInvoices = allInvoices.stream()
                .filter(i -> QuickBooksUtil.checkInvoiceMatchesCustomer(i, customer));

        // Filter for line items, construct map
        Map<InvoiceType, Invoice> invoiceMap = new HashMap<>();
        matchingInvoices.forEach(
                i -> {
                    // Get invoice type
                    InvoiceType invoiceType = QuickBooksUtil.getInvoiceTypeFromInvoice(i);
                    // Add to map if not null
                    if (invoiceType != null) {
                        invoiceMap.put(invoiceType, i);
                    }
                }
        );
        return invoiceMap;
    }

    /**
     * Creates the invoices relevant to the passed Registration, saving them in QuickBooks. Assumes invoices pertaining
     * to the registration do not yet exist. Should create one invoice for the relevant conference's school fee, and
     * another for delegate fees. The registration round should be inferred from the Registration's registration date,
     * and the due dates of the invoices should match this registration round. In addition, the customer attached to the
     * invoices should match the Registration's School, and numDelegates should equal the quantity on the delegate fee
     * invoice. If the PaymentMethod is CARD, a credit card processing fee item should also be added.
     * @param registration - The registration from which to create the invoices
     * @return - A map from InvoiceType to the created invoices
     */
    public Map<InvoiceType, Invoice> createInvoicesFromRegistration(@NonNull Registration registration) {
        // find matching customer
        Customer customer = this.queryCustomerFromSchool(registration.getSchool());
        // construct customer ref
        ReferenceType customerRef = QuickBooksUtil.getCustomerRefFromCustomer(customer);

        // get item objects relevant to this registration
        Map<ItemType, Item> itemMap = this.getRelevantItemsForRegistration(registration);
        // construct refs of these items
        Map<ItemType, ReferenceType> allItemRefMap = new HashMap<>();
        for (ItemType itemType: itemMap.keySet()) {
            ReferenceType itemRef = QuickBooksUtil.getItemRefFromItem(itemMap.get(itemType));
            allItemRefMap.put(itemType, itemRef);
        }

        // call helper to determine registration round/due date
        LocalDate registrationDate = registration.getRegistrationDate();
        Conference conference = registration.getConference();
        RegistrationRound registrationRound = QuickBooksUtil.getRegistrationRound(registrationDate, conference);
        LocalDate schoolFeeDueDate = registrationRound.getSchoolFeeDueDate();
        LocalDate delegateFeeDueDate = registrationRound.getDelegateFeeDueDate();
        // call helper to calculate credit card processing fees
        BigDecimal schoolFeeCreditCardProcessingFee = BigDecimal.valueOf(0);
        BigDecimal delegateFeeCreditCardProcessingFee = BigDecimal.valueOf(0);
        boolean isPayingByCard = registration.getPaymentMethod() == PaymentMethod.CARD;
        if (isPayingByCard) {
            schoolFeeCreditCardProcessingFee = QuickBooksUtil.calculateCreditCardProcessingFee(registration, true);
            delegateFeeCreditCardProcessingFee =
                    QuickBooksUtil.calculateCreditCardProcessingFee(registration, false);
        }
        // Construct school fee invoice
        PaymentMethod paymentMethod = registration.getPaymentMethod();
        Map<ItemType, BigDecimal> itemQuantityMap =
                QuickBooksUtil.constructItemQuantityMap(conference, paymentMethod, 0);
        Map<ItemType, BigDecimal> itemRateMap =
                QuickBooksUtil.constructItemRateMap(conference, true, schoolFeeCreditCardProcessingFee);
        Map<ItemType, ReferenceType> itemRefMap =
                QuickBooksUtil.constructItemRefMap(allItemRefMap, true, paymentMethod, conference);
        Invoice schoolFeeInvoice = QuickBooksUtil.constructInvoice(
                customerRef,
                QuickBooksUtil.getDate(registrationDate),
                QuickBooksUtil.getDate(schoolFeeDueDate),
                itemQuantityMap,
                itemRateMap,
                itemRefMap,
                registration.getPaymentMethod()
        );

        // Construct del fee invoice
        itemQuantityMap = QuickBooksUtil.constructItemQuantityMap(conference, paymentMethod, registration.getNumDelegates());
        itemRateMap = QuickBooksUtil.constructItemRateMap(conference, false, delegateFeeCreditCardProcessingFee);
        itemRefMap = QuickBooksUtil.constructItemRefMap(allItemRefMap, false, paymentMethod, conference);
        Invoice delegateFeeInvoice = QuickBooksUtil.constructInvoice(
                customerRef,
                QuickBooksUtil.getDate(registrationDate),
                QuickBooksUtil.getDate(delegateFeeDueDate),
                itemQuantityMap,
                itemRateMap,
                itemRefMap,
                registration.getPaymentMethod()
        );


        // add the invoices via the quickbooks api
        try {
            schoolFeeInvoice = dataService.add(schoolFeeInvoice);
        } catch (FMSException e) {
            throw new QuickBooksException("Error creating a new school fee invoice", e);
        }

        try {
            delegateFeeInvoice = dataService.add(delegateFeeInvoice);
        } catch (FMSException e) {
            throw new QuickBooksException("Error creating a new delegate fee invoice", e);
        }

        Map<InvoiceType, Invoice> invoiceMap;

        if (conference == Conference.BMUN) {
            invoiceMap = Map.of(
                    InvoiceType.BMUN_SCHOOL_FEE,
                    schoolFeeInvoice,
                    InvoiceType.BMUN_DELEGATE_FEE,
                    delegateFeeInvoice
            );
        } else {
            invoiceMap = Map.of(
                InvoiceType.FC_SCHOOL_FEE,
                schoolFeeInvoice,
                InvoiceType.FC_DELEGATE_FEE,
                delegateFeeInvoice
            );
        }

        return invoiceMap;
    }

    /**
     * Sends the passed invoice, using the email of the associated Customer.
     *
     * @param invoice      The Invoice to send
     * @param emailAddress The email to send the invoice to, if the invoice doesn't have an associated billing email
     */
    public void sendInvoice(@NonNull Invoice invoice, @NonNull String emailAddress) {
        String email = invoice.getBillEmail() == null ? emailAddress : invoice.getBillEmail().getAddress();
        try {
            this.dataService.sendEmail(invoice, email);
        } catch (FMSException e) {
            throw new QuickBooksException("Exception sending invoice", e);
        }
        invoice.setEmailStatus(EmailStatusEnum.EMAIL_SENT);
    }

    /**
     * Finds and returns the first invoice with matching memo
     * @param memoToMatch - A string containing the memo value to match against
     * @return invoice - The first invoice with a matching memo value
     */
    public Invoice getInvoiceWithMatchingMemo(String memoToMatch) {
        List<Invoice> invoices = this.getAllInvoices();

        for (Invoice inv : invoices) {
            MemoRef memo = inv.getCustomerMemo();
            if (memo != null && memo.getValue().equals(memoToMatch)) {
                return inv;
            }
        }
        return null;
    }

    /**
     * Queries for all invoices by calling dataService.findall
     * @return - A list of all existing invoices
     */
    private List<Invoice> getAllInvoices() {
        List<Invoice> invoices;
        try {
            invoices = this.dataService.findAll(new Invoice());
        } catch (FMSException e) {
            throw new QuickBooksException("Error fetching all invoices", e);
        }

        return invoices;
    }

    // Item methods

    /**
     * Queries for all items by calling dataService.findall
     * @return - A list of all existing items
     */
    private List<Item> getAllItems() {
        List<Item> items;
        try {
            items = this.dataService.findAll(new Item());
        } catch (FMSException e) {
            throw new QuickBooksException("Error fetching all invoices", e);
        }

        return items;
    }

    /**
     * Fetches the relevant QuickBooks Items that would appear in the invoices for the passed Registration. These Items
     * would be the relevant school fee and delegate fee items, and if paying by card the credit card processing item
     * too.
     * @param registration - The Registration for which to get relevant items
     * @return - A map from ItemType to the relevant Items
     */
    private Map<ItemType, Item> getRelevantItemsForRegistration(@NonNull Registration registration) {
        Map<ItemType, Item> itemMap = new HashMap<>();

        List<Item> allItems = this.getAllItems();

        if (registration.getConference() == Conference.BMUN) {
            Item schoolFeeItem = allItems.stream()
                    .filter(item -> item.getName().equals(ItemType.BMUN_SCHOOL_FEE.toString()))
                    .findAny().orElseThrow(() -> new QuickBooksException("Couldn't find BMUN School Fee Item", null));
            Item delegateFeeItem = allItems.stream()
                    .filter(item -> item.getName().equals(ItemType.BMUN_DELEGATE_FEE.toString()))
                    .findAny().orElseThrow(() -> new QuickBooksException("Couldn't find BMUN Delegate Fee Item", null));

            itemMap.put(ItemType.BMUN_SCHOOL_FEE, schoolFeeItem);
            itemMap.put(ItemType.BMUN_DELEGATE_FEE, delegateFeeItem);
        } else if (registration.getConference() == Conference.FC) {
            Item schoolFeeItem = allItems.stream()
                    .filter(item -> item.getName().equals(ItemType.FC_SCHOOL_FEE.toString()))
                    .findAny().orElseThrow(() -> new QuickBooksException("Couldn't find FC School Fee Item", null));
            Item delegateFeeItem = allItems.stream()
                    .filter(item -> item.getName().equals(ItemType.FC_DELEGATE_FEE.toString()))
                    .findAny().orElseThrow(() -> new QuickBooksException("Couldn't find FC Delegate Fee Item", null));

            itemMap.put(ItemType.FC_SCHOOL_FEE, schoolFeeItem);
            itemMap.put(ItemType.FC_DELEGATE_FEE, delegateFeeItem);
        }

        if (registration.getPaymentMethod() == PaymentMethod.CARD) {
            Item creditCardFeeItem = allItems.stream()
                    .filter(item -> item.getName().equals(ItemType.CREDIT_CARD_PROCESSING_FEE.toString()))
                    .findAny()
                    .orElseThrow(() -> new QuickBooksException("Couldn't find Credit Card Processing Fee Item", null));

            itemMap.put(ItemType.CREDIT_CARD_PROCESSING_FEE, creditCardFeeItem);
        }

        return itemMap;
    }
}
